// This file is @generated by foxglove-proto-gen
use crate::schemas::{descriptors, foxglove::*};
use crate::{Schema, Encode};
use bytes::BufMut;

impl Encode for CameraCalibration {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.CameraCalibration",
            "protobuf",
            descriptors::CAMERA_CALIBRATION,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for CircleAnnotation {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.CircleAnnotation",
            "protobuf",
            descriptors::CIRCLE_ANNOTATION,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for Color {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Color",
            "protobuf",
            descriptors::COLOR,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for CompressedImage {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.CompressedImage",
            "protobuf",
            descriptors::COMPRESSED_IMAGE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for CompressedVideo {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.CompressedVideo",
            "protobuf",
            descriptors::COMPRESSED_VIDEO,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for FrameTransform {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.FrameTransform",
            "protobuf",
            descriptors::FRAME_TRANSFORM,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for FrameTransforms {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.FrameTransforms",
            "protobuf",
            descriptors::FRAME_TRANSFORMS,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for GeoJson {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.GeoJson",
            "protobuf",
            descriptors::GEO_JSON,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for Grid {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Grid",
            "protobuf",
            descriptors::GRID,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for ImageAnnotations {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.ImageAnnotations",
            "protobuf",
            descriptors::IMAGE_ANNOTATIONS,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for KeyValuePair {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.KeyValuePair",
            "protobuf",
            descriptors::KEY_VALUE_PAIR,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for LaserScan {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.LaserScan",
            "protobuf",
            descriptors::LASER_SCAN,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for LocationFix {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.LocationFix",
            "protobuf",
            descriptors::LOCATION_FIX,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for Log {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Log",
            "protobuf",
            descriptors::LOG,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for PackedElementField {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.PackedElementField",
            "protobuf",
            descriptors::PACKED_ELEMENT_FIELD,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for Point2 {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Point2",
            "protobuf",
            descriptors::POINT2,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for Point3 {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Point3",
            "protobuf",
            descriptors::POINT3,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for PointCloud {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.PointCloud",
            "protobuf",
            descriptors::POINT_CLOUD,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for PointsAnnotation {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.PointsAnnotation",
            "protobuf",
            descriptors::POINTS_ANNOTATION,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for Pose {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Pose",
            "protobuf",
            descriptors::POSE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for PoseInFrame {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.PoseInFrame",
            "protobuf",
            descriptors::POSE_IN_FRAME,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for PosesInFrame {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.PosesInFrame",
            "protobuf",
            descriptors::POSES_IN_FRAME,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for Quaternion {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Quaternion",
            "protobuf",
            descriptors::QUATERNION,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for RawImage {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.RawImage",
            "protobuf",
            descriptors::RAW_IMAGE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for SceneEntity {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.SceneEntity",
            "protobuf",
            descriptors::SCENE_ENTITY,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for SceneEntityDeletion {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.SceneEntityDeletion",
            "protobuf",
            descriptors::SCENE_ENTITY_DELETION,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for SceneUpdate {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.SceneUpdate",
            "protobuf",
            descriptors::SCENE_UPDATE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for TextAnnotation {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.TextAnnotation",
            "protobuf",
            descriptors::TEXT_ANNOTATION,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for Vector2 {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Vector2",
            "protobuf",
            descriptors::VECTOR2,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

impl Encode for Vector3 {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Vector3",
            "protobuf",
            descriptors::VECTOR3,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}
