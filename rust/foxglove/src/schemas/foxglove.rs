// This file is @generated by prost-build.
/// A primitive representing an arrow
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ArrowPrimitive {
    /// Position of the arrow's tail and orientation of the arrow. Identity orientation means the arrow points in the +x direction.
    #[prost(message, optional, tag = "1")]
    pub pose: ::core::option::Option<Pose>,
    /// Length of the arrow shaft
    #[prost(double, tag = "2")]
    pub shaft_length: f64,
    /// Diameter of the arrow shaft
    #[prost(double, tag = "3")]
    pub shaft_diameter: f64,
    /// Length of the arrow head
    #[prost(double, tag = "4")]
    pub head_length: f64,
    /// Diameter of the arrow head
    #[prost(double, tag = "5")]
    pub head_diameter: f64,
    /// Color of the arrow
    #[prost(message, optional, tag = "6")]
    pub color: ::core::option::Option<Color>,
}
/// Camera calibration parameters
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CameraCalibration {
    /// Timestamp of calibration data
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Frame of reference for the camera. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
    #[prost(string, tag = "9")]
    pub frame_id: ::prost::alloc::string::String,
    /// Image width
    #[prost(fixed32, tag = "2")]
    pub width: u32,
    /// Image height
    #[prost(fixed32, tag = "3")]
    pub height: u32,
    /// Name of distortion model
    ///
    /// Supported parameters: `plumb_bob` (k1, k2, p1, p2, k3) and `rational_polynomial` (k1, k2, p1, p2, k3, k4, k5, k6). Distortion models are based on [OpenCV's](<https://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html>) [pinhole camera model](<https://en.wikipedia.org/wiki/Distortion_%28optics%29#Software_correction>). This is the same [implementation used by ROS](<http://docs.ros.org/en/diamondback/api/image_geometry/html/c++/pinhole__camera__model_8cpp_source.html>)
    #[prost(string, tag = "4")]
    pub distortion_model: ::prost::alloc::string::String,
    /// Distortion parameters
    #[prost(double, repeated, tag = "5")]
    pub d: ::prost::alloc::vec::Vec<f64>,
    /// Intrinsic camera matrix (3x3 row-major matrix)
    ///
    /// A 3x3 row-major matrix for the raw (distorted) image.
    ///
    /// Projects 3D points in the camera coordinate frame to 2D pixel coordinates using the focal lengths (fx, fy) and principal point (cx, cy).
    ///
    /// ```text
    ///     [fx  0 cx]
    /// K = [ 0 fy cy]
    ///     [ 0  0  1]
    /// ```
    ///
    /// length 9
    #[prost(double, repeated, tag = "6")]
    pub k: ::prost::alloc::vec::Vec<f64>,
    /// Rectification matrix (stereo cameras only, 3x3 row-major matrix)
    ///
    /// A rotation matrix aligning the camera coordinate system to the ideal stereo image plane so that epipolar lines in both stereo images are parallel.
    ///
    /// length 9
    #[prost(double, repeated, tag = "7")]
    pub r: ::prost::alloc::vec::Vec<f64>,
    /// Projection/camera matrix (3x4 row-major matrix)
    ///
    /// ```text
    ///     [fx'  0  cx' Tx]
    /// P = [ 0  fy' cy' Ty]
    ///     [ 0   0   1   0]
    /// ```
    ///
    /// By convention, this matrix specifies the intrinsic (camera) matrix of the processed (rectified) image. That is, the left 3x3 portion is the normal camera intrinsic matrix for the rectified image.
    ///
    /// It projects 3D points in the camera coordinate frame to 2D pixel coordinates using the focal lengths (fx', fy') and principal point (cx', cy') - these may differ from the values in K.
    ///
    /// For monocular cameras, Tx = Ty = 0. Normally, monocular cameras will also have R = the identity and P\[1:3,1:3\] = K.
    ///
    /// For a stereo pair, the fourth column \[Tx Ty 0\]' is related to the position of the optical center of the second camera in the first camera's frame. We assume Tz = 0 so both cameras are in the same stereo image plane. The first camera always has Tx = Ty = 0. For the right (second) camera of a horizontal stereo pair, Ty = 0 and Tx = -fx' * B, where B is the baseline between the cameras.
    ///
    /// Given a 3D point \[X Y Z\]', the projection (x, y) of the point onto the rectified image is given by:
    ///
    /// ```text
    /// [u v w]' = P * [X Y Z 1]'
    ///        x = u / w
    ///        y = v / w
    /// ```
    ///
    /// This holds for both images of a stereo pair.
    ///
    /// length 12
    #[prost(double, repeated, tag = "8")]
    pub p: ::prost::alloc::vec::Vec<f64>,
}
/// A circle annotation on a 2D image
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CircleAnnotation {
    /// Timestamp of circle
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Center of the circle in 2D image coordinates (pixels).
    /// The coordinate uses the top-left corner of the top-left pixel of the image as the origin.
    #[prost(message, optional, tag = "2")]
    pub position: ::core::option::Option<Point2>,
    /// Circle diameter in pixels
    #[prost(double, tag = "3")]
    pub diameter: f64,
    /// Line thickness in pixels
    #[prost(double, tag = "4")]
    pub thickness: f64,
    /// Fill color
    #[prost(message, optional, tag = "5")]
    pub fill_color: ::core::option::Option<Color>,
    /// Outline color
    #[prost(message, optional, tag = "6")]
    pub outline_color: ::core::option::Option<Color>,
}
/// A color in RGBA format
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Color {
    /// Red value between 0 and 1
    #[prost(double, tag = "1")]
    pub r: f64,
    /// Green value between 0 and 1
    #[prost(double, tag = "2")]
    pub g: f64,
    /// Blue value between 0 and 1
    #[prost(double, tag = "3")]
    pub b: f64,
    /// Alpha value between 0 and 1
    #[prost(double, tag = "4")]
    pub a: f64,
}
/// A compressed image
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompressedImage {
    /// Timestamp of image
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Frame of reference for the image. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
    #[prost(string, tag = "4")]
    pub frame_id: ::prost::alloc::string::String,
    /// Compressed image data
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// Image format
    ///
    /// Supported values: image media types supported by Chrome, such as `webp`, `jpeg`, `png`
    #[prost(string, tag = "3")]
    pub format: ::prost::alloc::string::String,
}
/// A single frame of a compressed video bitstream
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompressedVideo {
    /// Timestamp of video frame
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Frame of reference for the video.
    ///
    /// The origin of the frame is the optical center of the camera. +x points to the right in the video, +y points down, and +z points into the plane of the video.
    #[prost(string, tag = "2")]
    pub frame_id: ::prost::alloc::string::String,
    /// Compressed video frame data.
    ///
    /// For packet-based video codecs this data must begin and end on packet boundaries (no partial packets), and must contain enough video packets to decode exactly one image (either a keyframe or delta frame). Note: Foxglove does not support video streams that include B frames because they require lookahead.
    ///
    /// Specifically, the requirements for different `format` values are:
    ///
    /// - `h264`
    ///    - Use Annex B formatted data
    ///    - Each CompressedVideo message should contain enough NAL units to decode exactly one video frame
    ///    - Each message containing a key frame (IDR) must also include a SPS NAL unit
    ///
    /// - `h265` (HEVC)
    ///    - Use Annex B formatted data
    ///    - Each CompressedVideo message should contain enough NAL units to decode exactly one video frame
    ///    - Each message containing a key frame (IRAP) must also include relevant VPS/SPS/PPS NAL units
    ///
    /// - `vp9`
    ///    - Each CompressedVideo message should contain exactly one video frame
    ///
    /// - `av1`
    ///    - Use the "Low overhead bitstream format" (section 5.2)
    ///    - Each CompressedVideo message should contain enough OBUs to decode exactly one video frame
    ///    - Each message containing a key frame must also include a Sequence Header OBU
    #[prost(bytes = "vec", tag = "3")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// Video format.
    ///
    /// Supported values: `h264`, `h265`, `vp9`, `av1`.
    ///
    /// Note: compressed video support is subject to hardware limitations and patent licensing, so not all encodings may be supported on all platforms. See more about [H.265 support](<https://caniuse.com/hevc>), [VP9 support](<https://caniuse.com/webm>), and [AV1 support](<https://caniuse.com/av1>).
    #[prost(string, tag = "4")]
    pub format: ::prost::alloc::string::String,
}
/// A primitive representing a cube or rectangular prism
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CubePrimitive {
    /// Position of the center of the cube and orientation of the cube
    #[prost(message, optional, tag = "1")]
    pub pose: ::core::option::Option<Pose>,
    /// Size of the cube along each axis
    #[prost(message, optional, tag = "2")]
    pub size: ::core::option::Option<Vector3>,
    /// Color of the cube
    #[prost(message, optional, tag = "3")]
    pub color: ::core::option::Option<Color>,
}
/// A primitive representing a cylinder, elliptic cylinder, or truncated cone
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CylinderPrimitive {
    /// Position of the center of the cylinder and orientation of the cylinder. The flat face(s) are perpendicular to the z-axis.
    #[prost(message, optional, tag = "1")]
    pub pose: ::core::option::Option<Pose>,
    /// Size of the cylinder's bounding box
    #[prost(message, optional, tag = "2")]
    pub size: ::core::option::Option<Vector3>,
    /// 0-1, ratio of the diameter of the cylinder's bottom face (min z) to the bottom of the bounding box
    #[prost(double, tag = "3")]
    pub bottom_scale: f64,
    /// 0-1, ratio of the diameter of the cylinder's top face (max z) to the top of the bounding box
    #[prost(double, tag = "4")]
    pub top_scale: f64,
    /// Color of the cylinder
    #[prost(message, optional, tag = "5")]
    pub color: ::core::option::Option<Color>,
}
/// A transform between two reference frames in 3D space
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FrameTransform {
    /// Timestamp of transform
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Name of the parent frame
    #[prost(string, tag = "2")]
    pub parent_frame_id: ::prost::alloc::string::String,
    /// Name of the child frame
    #[prost(string, tag = "3")]
    pub child_frame_id: ::prost::alloc::string::String,
    /// Translation component of the transform
    #[prost(message, optional, tag = "4")]
    pub translation: ::core::option::Option<Vector3>,
    /// Rotation component of the transform
    #[prost(message, optional, tag = "5")]
    pub rotation: ::core::option::Option<Quaternion>,
}
/// An array of FrameTransform messages
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FrameTransforms {
    /// Array of transforms
    #[prost(message, repeated, tag = "1")]
    pub transforms: ::prost::alloc::vec::Vec<FrameTransform>,
}
/// GeoJSON data for annotating maps
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoJson {
    /// GeoJSON data encoded as a UTF-8 string
    #[prost(string, tag = "1")]
    pub geojson: ::prost::alloc::string::String,
}
/// A 2D grid of data
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Grid {
    /// Timestamp of grid
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Frame of reference
    #[prost(string, tag = "2")]
    pub frame_id: ::prost::alloc::string::String,
    /// Origin of grid's corner relative to frame of reference; grid is positioned in the x-y plane relative to this origin
    #[prost(message, optional, tag = "3")]
    pub pose: ::core::option::Option<Pose>,
    /// Number of grid columns
    #[prost(fixed32, tag = "4")]
    pub column_count: u32,
    /// Size of single grid cell along x and y axes, relative to `pose`
    #[prost(message, optional, tag = "5")]
    pub cell_size: ::core::option::Option<Vector2>,
    /// Number of bytes between rows in `data`
    #[prost(fixed32, tag = "6")]
    pub row_stride: u32,
    /// Number of bytes between cells within a row in `data`
    #[prost(fixed32, tag = "7")]
    pub cell_stride: u32,
    /// Fields in `data`. `red`, `green`, `blue`, and `alpha` are optional for customizing the grid's color.
    #[prost(message, repeated, tag = "8")]
    pub fields: ::prost::alloc::vec::Vec<PackedElementField>,
    /// Grid cell data, interpreted using `fields`, in row-major (y-major) order
    #[prost(bytes = "vec", tag = "9")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Array of annotations for a 2D image
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageAnnotations {
    /// Circle annotations
    #[prost(message, repeated, tag = "1")]
    pub circles: ::prost::alloc::vec::Vec<CircleAnnotation>,
    /// Points annotations
    #[prost(message, repeated, tag = "2")]
    pub points: ::prost::alloc::vec::Vec<PointsAnnotation>,
    /// Text annotations
    #[prost(message, repeated, tag = "3")]
    pub texts: ::prost::alloc::vec::Vec<TextAnnotation>,
}
/// A key with its associated value
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyValuePair {
    /// Key
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// Value
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
/// A single scan from a planar laser range-finder
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LaserScan {
    /// Timestamp of scan
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Frame of reference
    #[prost(string, tag = "2")]
    pub frame_id: ::prost::alloc::string::String,
    /// Origin of scan relative to frame of reference; points are positioned in the x-y plane relative to this origin; angles are interpreted as counterclockwise rotations around the z axis with 0 rad being in the +x direction
    #[prost(message, optional, tag = "3")]
    pub pose: ::core::option::Option<Pose>,
    /// Bearing of first point, in radians
    #[prost(double, tag = "4")]
    pub start_angle: f64,
    /// Bearing of last point, in radians
    #[prost(double, tag = "5")]
    pub end_angle: f64,
    /// Distance of detections from origin; assumed to be at equally-spaced angles between `start_angle` and `end_angle`
    #[prost(double, repeated, tag = "6")]
    pub ranges: ::prost::alloc::vec::Vec<f64>,
    /// Intensity of detections
    #[prost(double, repeated, tag = "7")]
    pub intensities: ::prost::alloc::vec::Vec<f64>,
}
/// A primitive representing a series of points connected by lines
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinePrimitive {
    /// Drawing primitive to use for lines
    #[prost(enumeration = "line_primitive::Type", tag = "1")]
    pub r#type: i32,
    /// Origin of lines relative to reference frame
    #[prost(message, optional, tag = "2")]
    pub pose: ::core::option::Option<Pose>,
    /// Line thickness
    #[prost(double, tag = "3")]
    pub thickness: f64,
    /// Indicates whether `thickness` is a fixed size in screen pixels (true), or specified in world coordinates and scales with distance from the camera (false)
    #[prost(bool, tag = "4")]
    pub scale_invariant: bool,
    /// Points along the line
    #[prost(message, repeated, tag = "5")]
    pub points: ::prost::alloc::vec::Vec<Point3>,
    /// Solid color to use for the whole line. One of `color` or `colors` must be provided.
    #[prost(message, optional, tag = "6")]
    pub color: ::core::option::Option<Color>,
    /// Per-point colors (if specified, must have the same length as `points`). One of `color` or `colors` must be provided.
    #[prost(message, repeated, tag = "7")]
    pub colors: ::prost::alloc::vec::Vec<Color>,
    /// Indices into the `points` and `colors` attribute arrays, which can be used to avoid duplicating attribute data.
    ///
    /// If omitted or empty, indexing will not be used. This default behavior is equivalent to specifying \[0, 1, ..., N-1\] for the indices (where N is the number of `points` provided).
    #[prost(fixed32, repeated, tag = "8")]
    pub indices: ::prost::alloc::vec::Vec<u32>,
}
/// Nested message and enum types in `LinePrimitive`.
pub mod line_primitive {
    /// An enumeration indicating how input points should be interpreted to create lines
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Connected line segments: 0-1, 1-2, ..., (n-1)-n
        LineStrip = 0,
        /// Closed polygon: 0-1, 1-2, ..., (n-1)-n, n-0
        LineLoop = 1,
        /// Individual line segments: 0-1, 2-3, 4-5, ...
        LineList = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::LineStrip => "LINE_STRIP",
                Self::LineLoop => "LINE_LOOP",
                Self::LineList => "LINE_LIST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LINE_STRIP" => Some(Self::LineStrip),
                "LINE_LOOP" => Some(Self::LineLoop),
                "LINE_LIST" => Some(Self::LineList),
                _ => None,
            }
        }
    }
}
/// A navigation satellite fix for any Global Navigation Satellite System
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationFix {
    /// Timestamp of the message
    #[prost(message, optional, tag = "6")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Frame for the sensor. Latitude and longitude readings are at the origin of the frame.
    #[prost(string, tag = "7")]
    pub frame_id: ::prost::alloc::string::String,
    /// Latitude in degrees
    #[prost(double, tag = "1")]
    pub latitude: f64,
    /// Longitude in degrees
    #[prost(double, tag = "2")]
    pub longitude: f64,
    /// Altitude in meters
    #[prost(double, tag = "3")]
    pub altitude: f64,
    /// Position covariance (m^2) defined relative to a tangential plane through the reported position. The components are East, North, and Up (ENU), in row-major order.
    ///
    /// length 9
    #[prost(double, repeated, tag = "4")]
    pub position_covariance: ::prost::alloc::vec::Vec<f64>,
    /// If `position_covariance` is available, `position_covariance_type` must be set to indicate the type of covariance.
    #[prost(enumeration = "location_fix::PositionCovarianceType", tag = "5")]
    pub position_covariance_type: i32,
}
/// Nested message and enum types in `LocationFix`.
pub mod location_fix {
    /// Type of position covariance
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PositionCovarianceType {
        Unknown = 0,
        Approximated = 1,
        DiagonalKnown = 2,
        Known = 3,
    }
    impl PositionCovarianceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Approximated => "APPROXIMATED",
                Self::DiagonalKnown => "DIAGONAL_KNOWN",
                Self::Known => "KNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "APPROXIMATED" => Some(Self::Approximated),
                "DIAGONAL_KNOWN" => Some(Self::DiagonalKnown),
                "KNOWN" => Some(Self::Known),
                _ => None,
            }
        }
    }
}
/// A log message
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Log {
    /// Timestamp of log message
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Log level
    #[prost(enumeration = "log::Level", tag = "2")]
    pub level: i32,
    /// Log message
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    /// Process or node name
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    /// Filename
    #[prost(string, tag = "5")]
    pub file: ::prost::alloc::string::String,
    /// Line number in the file
    #[prost(fixed32, tag = "6")]
    pub line: u32,
}
/// Nested message and enum types in `Log`.
pub mod log {
    /// Log level
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Level {
        Unknown = 0,
        Debug = 1,
        Info = 2,
        Warning = 3,
        Error = 4,
        Fatal = 5,
    }
    impl Level {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Debug => "DEBUG",
                Self::Info => "INFO",
                Self::Warning => "WARNING",
                Self::Error => "ERROR",
                Self::Fatal => "FATAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "DEBUG" => Some(Self::Debug),
                "INFO" => Some(Self::Info),
                "WARNING" => Some(Self::Warning),
                "ERROR" => Some(Self::Error),
                "FATAL" => Some(Self::Fatal),
                _ => None,
            }
        }
    }
}
/// A primitive representing a 3D model file loaded from an external URL or embedded data
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelPrimitive {
    /// Origin of model relative to reference frame
    #[prost(message, optional, tag = "1")]
    pub pose: ::core::option::Option<Pose>,
    /// Scale factor to apply to the model along each axis
    #[prost(message, optional, tag = "2")]
    pub scale: ::core::option::Option<Vector3>,
    /// Solid color to use for the whole model if `override_color` is true.
    #[prost(message, optional, tag = "3")]
    pub color: ::core::option::Option<Color>,
    /// Whether to use the color specified in `color` instead of any materials embedded in the original model.
    #[prost(bool, tag = "4")]
    pub override_color: bool,
    /// URL pointing to model file. One of `url` or `data` should be provided.
    #[prost(string, tag = "5")]
    pub url: ::prost::alloc::string::String,
    /// [Media type](<https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types>) of embedded model (e.g. `model/gltf-binary`). Required if `data` is provided instead of `url`. Overrides the inferred media type if `url` is provided.
    #[prost(string, tag = "6")]
    pub media_type: ::prost::alloc::string::String,
    /// Embedded model. One of `url` or `data` should be provided. If `data` is provided, `media_type` must be set to indicate the type of the data.
    #[prost(bytes = "vec", tag = "7")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// A field present within each element in a byte array of packed elements.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackedElementField {
    /// Name of the field
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Byte offset from start of data buffer
    #[prost(fixed32, tag = "2")]
    pub offset: u32,
    /// Type of data in the field. Integers are stored using little-endian byte order.
    #[prost(enumeration = "packed_element_field::NumericType", tag = "3")]
    pub r#type: i32,
}
/// Nested message and enum types in `PackedElementField`.
pub mod packed_element_field {
    /// Numeric type
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NumericType {
        Unknown = 0,
        Uint8 = 1,
        Int8 = 2,
        Uint16 = 3,
        Int16 = 4,
        Uint32 = 5,
        Int32 = 6,
        Float32 = 7,
        Float64 = 8,
    }
    impl NumericType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Uint8 => "UINT8",
                Self::Int8 => "INT8",
                Self::Uint16 => "UINT16",
                Self::Int16 => "INT16",
                Self::Uint32 => "UINT32",
                Self::Int32 => "INT32",
                Self::Float32 => "FLOAT32",
                Self::Float64 => "FLOAT64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "UINT8" => Some(Self::Uint8),
                "INT8" => Some(Self::Int8),
                "UINT16" => Some(Self::Uint16),
                "INT16" => Some(Self::Int16),
                "UINT32" => Some(Self::Uint32),
                "INT32" => Some(Self::Int32),
                "FLOAT32" => Some(Self::Float32),
                "FLOAT64" => Some(Self::Float64),
                _ => None,
            }
        }
    }
}
/// A point representing a position in 2D space
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Point2 {
    /// x coordinate position
    #[prost(double, tag = "1")]
    pub x: f64,
    /// y coordinate position
    #[prost(double, tag = "2")]
    pub y: f64,
}
/// A point representing a position in 3D space
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Point3 {
    /// x coordinate position
    #[prost(double, tag = "1")]
    pub x: f64,
    /// y coordinate position
    #[prost(double, tag = "2")]
    pub y: f64,
    /// z coordinate position
    #[prost(double, tag = "3")]
    pub z: f64,
}
/// A collection of N-dimensional points, which may contain additional fields with information like normals, intensity, etc.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PointCloud {
    /// Timestamp of point cloud
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Frame of reference
    #[prost(string, tag = "2")]
    pub frame_id: ::prost::alloc::string::String,
    /// The origin of the point cloud relative to the frame of reference
    #[prost(message, optional, tag = "3")]
    pub pose: ::core::option::Option<Pose>,
    /// Number of bytes between points in the `data`
    #[prost(fixed32, tag = "4")]
    pub point_stride: u32,
    /// Fields in `data`. At least 2 coordinate fields from `x`, `y`, and `z` are required for each point's position; `red`, `green`, `blue`, and `alpha` are optional for customizing each point's color.
    #[prost(message, repeated, tag = "5")]
    pub fields: ::prost::alloc::vec::Vec<PackedElementField>,
    /// Point data, interpreted using `fields`
    #[prost(bytes = "vec", tag = "6")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// An array of points on a 2D image
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PointsAnnotation {
    /// Timestamp of annotation
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Type of points annotation to draw
    #[prost(enumeration = "points_annotation::Type", tag = "2")]
    pub r#type: i32,
    /// Points in 2D image coordinates (pixels).
    /// These coordinates use the top-left corner of the top-left pixel of the image as the origin.
    #[prost(message, repeated, tag = "3")]
    pub points: ::prost::alloc::vec::Vec<Point2>,
    /// Outline color
    #[prost(message, optional, tag = "4")]
    pub outline_color: ::core::option::Option<Color>,
    /// Per-point colors, if `type` is `POINTS`, or per-segment stroke colors, if `type` is `LINE_LIST`, `LINE_STRIP` or `LINE_LOOP`.
    #[prost(message, repeated, tag = "5")]
    pub outline_colors: ::prost::alloc::vec::Vec<Color>,
    /// Fill color
    #[prost(message, optional, tag = "6")]
    pub fill_color: ::core::option::Option<Color>,
    /// Stroke thickness in pixels
    #[prost(double, tag = "7")]
    pub thickness: f64,
}
/// Nested message and enum types in `PointsAnnotation`.
pub mod points_annotation {
    /// Type of points annotation
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unknown = 0,
        /// Individual points: 0, 1, 2, ...
        Points = 1,
        /// Closed polygon: 0-1, 1-2, ..., (n-1)-n, n-0
        LineLoop = 2,
        /// Connected line segments: 0-1, 1-2, ..., (n-1)-n
        LineStrip = 3,
        /// Individual line segments: 0-1, 2-3, 4-5, ...
        LineList = 4,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Points => "POINTS",
                Self::LineLoop => "LINE_LOOP",
                Self::LineStrip => "LINE_STRIP",
                Self::LineList => "LINE_LIST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "POINTS" => Some(Self::Points),
                "LINE_LOOP" => Some(Self::LineLoop),
                "LINE_STRIP" => Some(Self::LineStrip),
                "LINE_LIST" => Some(Self::LineList),
                _ => None,
            }
        }
    }
}
/// A position and orientation for an object or reference frame in 3D space
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Pose {
    /// Point denoting position in 3D space
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<Vector3>,
    /// Quaternion denoting orientation in 3D space
    #[prost(message, optional, tag = "2")]
    pub orientation: ::core::option::Option<Quaternion>,
}
/// A timestamped pose for an object or reference frame in 3D space
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PoseInFrame {
    /// Timestamp of pose
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Frame of reference for pose position and orientation
    #[prost(string, tag = "2")]
    pub frame_id: ::prost::alloc::string::String,
    /// Pose in 3D space
    #[prost(message, optional, tag = "3")]
    pub pose: ::core::option::Option<Pose>,
}
/// An array of timestamped poses for an object or reference frame in 3D space
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PosesInFrame {
    /// Timestamp of pose
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Frame of reference for pose position and orientation
    #[prost(string, tag = "2")]
    pub frame_id: ::prost::alloc::string::String,
    /// Poses in 3D space
    #[prost(message, repeated, tag = "3")]
    pub poses: ::prost::alloc::vec::Vec<Pose>,
}
/// A [quaternion](<https://eater.net/quaternions>) representing a rotation in 3D space
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Quaternion {
    /// x value
    #[prost(double, tag = "1")]
    pub x: f64,
    /// y value
    #[prost(double, tag = "2")]
    pub y: f64,
    /// z value
    #[prost(double, tag = "3")]
    pub z: f64,
    /// w value
    #[prost(double, tag = "4")]
    pub w: f64,
}
/// A raw image
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RawImage {
    /// Timestamp of image
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Frame of reference for the image. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
    #[prost(string, tag = "7")]
    pub frame_id: ::prost::alloc::string::String,
    /// Image width
    #[prost(fixed32, tag = "2")]
    pub width: u32,
    /// Image height
    #[prost(fixed32, tag = "3")]
    pub height: u32,
    /// Encoding of the raw image data
    ///
    /// Supported values: `8UC1`, `8UC3`, `16UC1` (little endian), `32FC1` (little endian), `bayer_bggr8`, `bayer_gbrg8`, `bayer_grbg8`, `bayer_rggb8`, `bgr8`, `bgra8`, `mono8`, `mono16`, `rgb8`, `rgba8`, `uyvy` or `yuv422`, `yuyv` or `yuv422_yuy2`
    #[prost(string, tag = "4")]
    pub encoding: ::prost::alloc::string::String,
    /// Byte length of a single row
    #[prost(fixed32, tag = "5")]
    pub step: u32,
    /// Raw image data
    #[prost(bytes = "vec", tag = "6")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// A visual element in a 3D scene. An entity may be composed of multiple primitives which all share the same frame of reference.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneEntity {
    /// Timestamp of the entity
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Frame of reference
    #[prost(string, tag = "2")]
    pub frame_id: ::prost::alloc::string::String,
    /// Identifier for the entity. A entity will replace any prior entity on the same topic with the same `id`.
    #[prost(string, tag = "3")]
    pub id: ::prost::alloc::string::String,
    /// Length of time (relative to `timestamp`) after which the entity should be automatically removed. Zero value indicates the entity should remain visible until it is replaced or deleted.
    #[prost(message, optional, tag = "4")]
    pub lifetime: ::core::option::Option<::prost_types::Duration>,
    /// Whether the entity should keep its location in the fixed frame (false) or follow the frame specified in `frame_id` as it moves relative to the fixed frame (true)
    #[prost(bool, tag = "5")]
    pub frame_locked: bool,
    /// Additional user-provided metadata associated with the entity. Keys must be unique.
    #[prost(message, repeated, tag = "6")]
    pub metadata: ::prost::alloc::vec::Vec<KeyValuePair>,
    /// Arrow primitives
    #[prost(message, repeated, tag = "7")]
    pub arrows: ::prost::alloc::vec::Vec<ArrowPrimitive>,
    /// Cube primitives
    #[prost(message, repeated, tag = "8")]
    pub cubes: ::prost::alloc::vec::Vec<CubePrimitive>,
    /// Sphere primitives
    #[prost(message, repeated, tag = "9")]
    pub spheres: ::prost::alloc::vec::Vec<SpherePrimitive>,
    /// Cylinder primitives
    #[prost(message, repeated, tag = "10")]
    pub cylinders: ::prost::alloc::vec::Vec<CylinderPrimitive>,
    /// Line primitives
    #[prost(message, repeated, tag = "11")]
    pub lines: ::prost::alloc::vec::Vec<LinePrimitive>,
    /// Triangle list primitives
    #[prost(message, repeated, tag = "12")]
    pub triangles: ::prost::alloc::vec::Vec<TriangleListPrimitive>,
    /// Text primitives
    #[prost(message, repeated, tag = "13")]
    pub texts: ::prost::alloc::vec::Vec<TextPrimitive>,
    /// Model primitives
    #[prost(message, repeated, tag = "14")]
    pub models: ::prost::alloc::vec::Vec<ModelPrimitive>,
}
/// Command to remove previously published entities
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneEntityDeletion {
    /// Timestamp of the deletion. Only matching entities earlier than this timestamp will be deleted.
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Type of deletion action to perform
    #[prost(enumeration = "scene_entity_deletion::Type", tag = "2")]
    pub r#type: i32,
    /// Identifier which must match if `type` is `MATCHING_ID`.
    #[prost(string, tag = "3")]
    pub id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `SceneEntityDeletion`.
pub mod scene_entity_deletion {
    /// An enumeration indicating which entities should match a SceneEntityDeletion command
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Delete the existing entity on the same topic that has the provided `id`
        MatchingId = 0,
        /// Delete all existing entities on the same topic
        All = 1,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::MatchingId => "MATCHING_ID",
                Self::All => "ALL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MATCHING_ID" => Some(Self::MatchingId),
                "ALL" => Some(Self::All),
                _ => None,
            }
        }
    }
}
/// An update to the entities displayed in a 3D scene
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneUpdate {
    /// Scene entities to delete
    #[prost(message, repeated, tag = "1")]
    pub deletions: ::prost::alloc::vec::Vec<SceneEntityDeletion>,
    /// Scene entities to add or replace
    #[prost(message, repeated, tag = "2")]
    pub entities: ::prost::alloc::vec::Vec<SceneEntity>,
}
/// A primitive representing a sphere or ellipsoid
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SpherePrimitive {
    /// Position of the center of the sphere and orientation of the sphere
    #[prost(message, optional, tag = "1")]
    pub pose: ::core::option::Option<Pose>,
    /// Size (diameter) of the sphere along each axis
    #[prost(message, optional, tag = "2")]
    pub size: ::core::option::Option<Vector3>,
    /// Color of the sphere
    #[prost(message, optional, tag = "3")]
    pub color: ::core::option::Option<Color>,
}
/// A text label on a 2D image
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextAnnotation {
    /// Timestamp of annotation
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Bottom-left origin of the text label in 2D image coordinates (pixels).
    /// The coordinate uses the top-left corner of the top-left pixel of the image as the origin.
    #[prost(message, optional, tag = "2")]
    pub position: ::core::option::Option<Point2>,
    /// Text to display
    #[prost(string, tag = "3")]
    pub text: ::prost::alloc::string::String,
    /// Font size in pixels
    #[prost(double, tag = "4")]
    pub font_size: f64,
    /// Text color
    #[prost(message, optional, tag = "5")]
    pub text_color: ::core::option::Option<Color>,
    /// Background fill color
    #[prost(message, optional, tag = "6")]
    pub background_color: ::core::option::Option<Color>,
}
/// A primitive representing a text label
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextPrimitive {
    /// Position of the center of the text box and orientation of the text. Identity orientation means the text is oriented in the xy-plane and flows from -x to +x.
    #[prost(message, optional, tag = "1")]
    pub pose: ::core::option::Option<Pose>,
    /// Whether the text should respect `pose.orientation` (false) or always face the camera (true)
    #[prost(bool, tag = "2")]
    pub billboard: bool,
    /// Font size (height of one line of text)
    #[prost(double, tag = "3")]
    pub font_size: f64,
    /// Indicates whether `font_size` is a fixed size in screen pixels (true), or specified in world coordinates and scales with distance from the camera (false)
    #[prost(bool, tag = "4")]
    pub scale_invariant: bool,
    /// Color of the text
    #[prost(message, optional, tag = "5")]
    pub color: ::core::option::Option<Color>,
    /// Text
    #[prost(string, tag = "6")]
    pub text: ::prost::alloc::string::String,
}
/// A primitive representing a set of triangles or a surface tiled by triangles
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TriangleListPrimitive {
    /// Origin of triangles relative to reference frame
    #[prost(message, optional, tag = "1")]
    pub pose: ::core::option::Option<Pose>,
    /// Vertices to use for triangles, interpreted as a list of triples (0-1-2, 3-4-5, ...)
    #[prost(message, repeated, tag = "2")]
    pub points: ::prost::alloc::vec::Vec<Point3>,
    /// Solid color to use for the whole shape. One of `color` or `colors` must be provided.
    #[prost(message, optional, tag = "3")]
    pub color: ::core::option::Option<Color>,
    /// Per-vertex colors (if specified, must have the same length as `points`). One of `color` or `colors` must be provided.
    #[prost(message, repeated, tag = "4")]
    pub colors: ::prost::alloc::vec::Vec<Color>,
    /// Indices into the `points` and `colors` attribute arrays, which can be used to avoid duplicating attribute data.
    ///
    /// If omitted or empty, indexing will not be used. This default behavior is equivalent to specifying \[0, 1, ..., N-1\] for the indices (where N is the number of `points` provided).
    #[prost(fixed32, repeated, tag = "5")]
    pub indices: ::prost::alloc::vec::Vec<u32>,
}
/// A vector in 2D space that represents a direction only
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Vector2 {
    /// x coordinate length
    #[prost(double, tag = "1")]
    pub x: f64,
    /// y coordinate length
    #[prost(double, tag = "2")]
    pub y: f64,
}
/// A vector in 3D space that represents a direction only
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Vector3 {
    /// x coordinate length
    #[prost(double, tag = "1")]
    pub x: f64,
    /// y coordinate length
    #[prost(double, tag = "2")]
    pub y: f64,
    /// z coordinate length
    #[prost(double, tag = "3")]
    pub z: f64,
}
